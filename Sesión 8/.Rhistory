# Limpieza de entorno
rm(list=ls())
dev.off()
pacman::p_load(tidyverse,  # Para manipular datos
stargazer,  # Para comparar resultados
quantmod    # Para traer datos financieros
)
# Para obtener los mismos resultados, debemos fijar una semilla
set.seed(377)
n = 10000
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
n = 10
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
n = 100
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
n = 1000
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
n = 10000
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
lognormal = rlnorm(n,0,1); lognormal
# Graficamente
lognormal_DF = as.data.frame(lognormal)
ggplot(lognormal_DF, aes(x = lognormal)) +
geom_histogram(color = "black", fill = "royalblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
# Para la T-Student debemos fijar grados de libertad
gl = 2
tst = rt(n,gl); tst
tst_DF = as.data.frame(tst)
ggplot(tst_DF, aes(x = tst)) +
geom_histogram(color = "black", fill = "royalblue",
alpha = 0.5, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
# Para la T-Student debemos fijar grados de libertad
gl = 4
tst = rt(n,gl); tst
tst_DF = as.data.frame(tst)
ggplot(tst_DF, aes(x = tst)) +
geom_histogram(color = "black", fill = "royalblue",
alpha = 0.5, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
n = 100
tst = rt(n,gl); tst
tst_DF = as.data.frame(tst)
ggplot(tst_DF, aes(x = tst)) +
geom_histogram(color = "black", fill = "royalblue",
alpha = 0.5, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
APPLE = getSymbols("AAPL",
from = "2023-01-01",      # Traemos los datos desde el 90'
source = "yahoo",
periodicity = "daily",
auto.assign = F)[,4]      # Con [,4] traemos la columna con
View(APPLE)
# Retornos de Apple
APP_R = diff(log(APPLE))
APP_R = na.omit(APP_R)
chartSeries(APP_R,
type = "auto",
name = "",
theme = chartTheme("white", up.col = "gray"),
show.grid = F,
TA = NULL)
length(APP_R) # 413 datos
# Media y desviación estándar de los retornos
mu = mean(APP_R); mu
DS = sd(APP_R); DS
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
# Aquí colocamos el proceso a generar con GGplot
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
# Colocamos los labels
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia") +
# Estilo o tema de gráfico.
theme_classic()
n = 100
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
n = 1000
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
n = 500
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
n = 100
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
n = 453
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
# Aquí colocamos el proceso a generar con GGplot
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
# Colocamos los labels
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia") +
# Estilo o tema de gráfico.
theme_classic()
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia",
color = "Distribuciones") +
# En esta sección incluímos cada distribución
stat_function(fun = dnorm, args = list(mean = mu, sd = DS),
aes(color = "Normal"), size = 1, linetype = "solid") +
stat_function(fun = dcauchy, args = list(location = mu, scale = DS),
aes(color = "Cauchy"), size = 1, linetype = "solid") +
stat_function(fun = function(x) dt((x - mu) / DS, df = gl) / DS,
aes(color = "T-Student"), size = 1, linetype = "solid")  +
# Colocamos la etiqueta
scale_color_manual(name = "Distribuciones",
values = c("Normal" = "purple",
"Cauchy" = "blue",
"T-Student" = "lightblue")) +
# Tema del gráfico
theme_classic()
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia",
color = "Distribuciones") +
# En esta sección incluímos cada distribución
stat_function(fun = dnorm, args = list(mean = mu, sd = DS),
aes(color = "Normal"), size = 1, linetype = "solid") +
stat_function(fun = dcauchy, args = list(location = mu, scale = DS),
aes(color = "Cauchy"), size = 1, linetype = "solid") +
stat_function(fun = function(x) dt((x - mu) / DS, df = gl) / DS,
aes(color = "T-Student"), size = 1, linetype = "solid")  +
# Colocamos la etiqueta
scale_color_manual(name = "Distribuciones",
values = c("Normal" = "purple",
"Cauchy" = "blue",
"T-Student" = "lightblue")) +
# Tema del gráfico
theme_minimal()
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia",
color = "Distribuciones") +
# En esta sección incluímos cada distribución
stat_function(fun = dnorm, args = list(mean = mu, sd = DS),
aes(color = "Normal"), size = 1, linetype = "solid") +
stat_function(fun = dcauchy, args = list(location = mu, scale = DS),
aes(color = "Cauchy"), size = 1, linetype = "solid") +
stat_function(fun = function(x) dt((x - mu) / DS, df = gl) / DS,
aes(color = "T-Student"), size = 1, linetype = "solid")  +
# Colocamos la etiqueta
scale_color_manual(name = "Distribuciones",
values = c("Normal" = "purple",
"Cauchy" = "blue",
"T-Student" = "lightblue")) +
# Tema del gráfico
theme_dark()
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia",
color = "Distribuciones") +
# En esta sección incluímos cada distribución
stat_function(fun = dnorm, args = list(mean = mu, sd = DS),
aes(color = "Normal"), size = 1, linetype = "solid") +
stat_function(fun = dcauchy, args = list(location = mu, scale = DS),
aes(color = "Cauchy"), size = 1, linetype = "solid") +
stat_function(fun = function(x) dt((x - mu) / DS, df = gl) / DS,
aes(color = "T-Student"), size = 1, linetype = "solid")  +
# Colocamos la etiqueta
scale_color_manual(name = "Distribuciones",
values = c("Normal" = "purple",
"Cauchy" = "blue",
"T-Student" = "lightblue")) +
# Tema del gráfico
theme_classic()
# Fijamos nuestra valor de significancia alpha del 5%
a = 0.05
n = 10000
nvec = rnorm(n,mu,DS)
hist(as.data.frame(nvec))
hist(nvec)
# Hallamos el valor crítico del primer cuantil 5 (Value at Risk)
VaR_normal = quantile(nvec,a)
VaR_normal
# Ahora, encontramos la media del primer cuantil de las repeticiones (ES)
ES_normal = mean(nvec[nvec<VaR_normal])
ES_normal
mvec = sample(as.vector(APP_R), n, replace = T)
ggplot(as.data.frame(mvec), aes(x = mvec)) +
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
labs(title = "Resampleo de los datos",
subtitle = "[Retornos de Apple a partir de 2023]",
x = "Retorno",
y = "Frecuencia",
) +
theme_classic()
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
# Aquí colocamos el proceso a generar con GGplot
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
# Colocamos los labels
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia") +
# Estilo o tema de gráfico.
theme_classic()
ggplot(as.data.frame(mvec), aes(x = mvec)) +
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
labs(title = "Resampleo de los datos",
subtitle = "[Retornos de Apple a partir de 2023]",
x = "Retorno",
y = "Frecuencia",
) +
theme_classic()
# VaR
VaR_sample = quantile(mvec,a)
VaR_sample
# ES
ES_sample = mean(nvec[nvec<VaR_sample])
ES_sample
# Generamos un VaR de forma paramétrica
VaR_q5 = quantile(APP_R, probs = 0.05)
VaR_q5  # VaR al 95%
# Al igual que el Expected Shortfall
q_5 = 0.95
# Generamos un VaR de forma paramétrica
VaR_q5 = quantile(APP_R, probs = 0.05)
VaR_q5  # VaR al 95%
# Al igual que el Expected Shortfall
q_5 = 0.95
ES_q5 = mu-(dnorm(qnorm(q_5))/(1-q_5))*DS
ES_q5  # La perdida es mayor
ES = c(ES_normal, ES_sample, ES_q5)
VaR = c(VaR_normal, VaR_sample, VaR_q5)
ES
VaR
resultados = data.frame(ES=ES, VaR=VaR)
# Cambiar los nombres de las filas
rownames(resultados) = c("Simulaciones con distribución normal",
"Simulaciones con muestra de los retornos",
"Forma histórica")
# Resultados en tabla
resultados
# Resultados en tabla
resultadost(resultados)
t(resultados)
print(t(resultados))
print(resultados)
stargazer(resultados, type = "text")
View(resultados)
View(resultados)
# Limpieza de entorno
rm(list = ls())
dev.off()
library(pacman)
pacman::p_load(vars,       # Para usar modelos VAR
urca,       # Para hacer pruebas Dickey Fuller
ggplot2,    # Para hacer gráficos con ggplot
ggfortify,  # Para hacer gráficos de series de tiempo
gridExtra,  # Para generar gráficos multiples
dplyr,      # Para manipulación de dataframes
tidyr,      # Para manipulación de dataframes
readxl,     # Para leer archivos xlsx.
tsDyn,      # Para usar metodología Johansen
VAR.etp     # Para estimar modelos VAR
)
n = 453
normal = rnorm(n,0,1); normal
# Graficamente
normal_DF = as.data.frame(normal)
ggplot(normal_DF, aes(x = normal)) +
geom_histogram(color = "black", fill = "skyblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
lognormal = rlnorm(n,0,1); lognormal
# Graficamente
lognormal_DF = as.data.frame(lognormal)
ggplot(lognormal_DF, aes(x = lognormal)) +
geom_histogram(color = "black", fill = "royalblue",
alpha = 0.7, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
# Para la T-Student debemos fijar grados de libertad
gl = 4
tst = rt(n,gl); tst
tst_DF = as.data.frame(tst)
ggplot(tst_DF, aes(x = tst)) +
geom_histogram(color = "black", fill = "royalblue",
alpha = 0.5, bins = 50) +
labs(title = "Densidad de los datos",
x = "Valor",
y = "Frecuencia") +
theme_minimal()
APPLE = getSymbols("AAPL",
from = "2023-01-01",      # Traemos los datos desde el 90'
source = "yahoo",
periodicity = "daily",
auto.assign = F)[,4]      # Con [,4] traemos la columna con
# Retornos de Apple
APP_R = diff(log(APPLE))
APP_R = na.omit(APP_R)
chartSeries(APP_R,
type = "auto",
name = "",
theme = chartTheme("white", up.col = "gray"),
show.grid = F,
TA = NULL)
length(APP_R) # 413 datos
# Media y desviación estándar de los retornos
mu = mean(APP_R); mu
DS = sd(APP_R); DS
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
# Aquí colocamos el proceso a generar con GGplot
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
# Colocamos los labels
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia") +
# Estilo o tema de gráfico.
theme_classic()
ggplot(as.data.frame(APP_R), aes(x = AAPL.Close)) +
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
labs(title = "Retornos de Apple",
subtitle = "[2023/01/01 - Hoy]",
x = "Retorno",
y = "Frecuencia",
color = "Distribuciones") +
# En esta sección incluímos cada distribución
stat_function(fun = dnorm, args = list(mean = mu, sd = DS),
aes(color = "Normal"), size = 1, linetype = "solid") +
stat_function(fun = dcauchy, args = list(location = mu, scale = DS),
aes(color = "Cauchy"), size = 1, linetype = "solid") +
stat_function(fun = function(x) dt((x - mu) / DS, df = gl) / DS,
aes(color = "T-Student"), size = 1, linetype = "solid")  +
# Colocamos la etiqueta
scale_color_manual(name = "Distribuciones",
values = c("Normal" = "purple",
"Cauchy" = "blue",
"T-Student" = "lightblue")) +
# Tema del gráfico
theme_classic()
# Fijamos nuestra valor de significancia alpha del 5%
a = 0.05
n = 10000
nvec = rnorm(n,mu,DS)
hist(nvec)
# Hallamos el valor crítico del primer cuantil 5 (Value at Risk)
VaR_normal = quantile(nvec,a)
VaR_normal
# Ahora, encontramos la media del primer cuantil de las repeticiones (ES)
ES_normal = mean(nvec[nvec<VaR_normal])
ES_normal
mvec = sample(as.vector(APP_R), n, replace = T)
ggplot(as.data.frame(mvec), aes(x = mvec)) +
geom_histogram(color = "gray20", fill = "coral3",
alpha = 0.7, bins = 50) +
labs(title = "Resampleo de los datos",
subtitle = "[Retornos de Apple a partir de 2023]",
x = "Retorno",
y = "Frecuencia",
) +
theme_classic()
# VaR
VaR_sample = quantile(mvec,a)
VaR_sample
# ES
ES_sample = mean(nvec[nvec<VaR_sample])
ES_sample
# Generamos un VaR de forma paramétrica
VaR_q5 = quantile(APP_R, probs = 0.05)
VaR_q5  # VaR al 95%
# Al igual que el Expected Shortfall
q_5 = 0.95
# Limpieza de entorno
rm(list = ls())
dev.off()
library(pacman)
pacman::p_load(vars,       # Para usar modelos VAR
urca,       # Para hacer pruebas Dickey Fuller
ggplot2,    # Para hacer gráficos con ggplot
ggfortify,  # Para hacer gráficos de series de tiempo
gridExtra,  # Para generar gráficos multiples
dplyr,      # Para manipulación de dataframes
tidyr,      # Para manipulación de dataframes
readxl,     # Para leer archivos xlsx.
tsDyn,      # Para usar metodología Johansen
VAR.etp     # Para estimar modelos VAR
)
