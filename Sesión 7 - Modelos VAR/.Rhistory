# Valores Numéricos
pronostico
# En nivel
niveles = as.data.frame(pronostico)
exp(niveles)
# Pronóstico gráficamente.
autoplot(pronostico, predict.linetype = 'dashed', conf.int = T,
ylab = "Log PIB", xlab ="")+
ggtitle("Pronóstico del Log PIB de Colombia", subtitle = "(2020 Q2 - 2022 Q2)")
pacman::p_load(tseries,     # Para usar series de tiempo
tidyverse,   # Paquete que contiene dplyr y GGplot2
forecast,    # Para pronósticar series
quantmod,    # Para hacer gráficas atractivas
qqplotr,     # Para generar gráficos de normalidad
vars         # Para probar la hipótesis de heterocedasticidad
)
# Prueba ARCH
arch.test(arima013, output = T)
# Prueba ARCH
arch.test(arima013)
pacman::p_load(tseries,     # Para usar series de tiempo
tidyverse,   # Paquete que contiene dplyr y GGplot2
forecast,    # Para pronósticar series
quantmod,    # Para hacer gráficas atractivas
qqplotr      # Para generar gráficos de normalidad
)
# QQplot
qqPlot(res)   # Parece cumplirse, es muy subjetivo.
# QQplot
qqplot(res)   # Parece cumplirse, es muy subjetivo.
# QQplot
qqPlot(res)   # Parece cumplirse, es muy subjetivo.
pacman::p_load(tseries,     # Para usar series de tiempo
tidyverse,   # Paquete que contiene dplyr y GGplot2
forecast,    # Para pronósticar series
quantmod,    # Para hacer gráficas atractivas
car          # Para generar gráficos de normalidad
)
# QQplot
qqPlot(res)   # Parece cumplirse, es muy subjetivo.
# Prueba Jarque Bera
jarque.bera.test(res)  # No se cumple la normalidad de los errores.
# FAC y FACP
par(mfrow = c(1,2))
acf(res, main = "FAC de los errores")
pacf(res, main = "FACP de los errores")
par(mfrow = c(1,1))
# Prueba Ljung - Box
Box.test(res, lag=4, type='Ljung-Box')
Box.test(res, lag=8, type='Ljung-Box')
# FAC y FACP
par(mfrow = c(1,2))
acf(res^2, main = "FAC del Δ% PIB")
pacf(res^2, main = "FACP del  Δ% PIB")
par(mfrow = c(1,1))
pacman::p_load(tseries,     # Para usar series de tiempo
tidyverse,   # Paquete que contiene dplyr y GGplot2
forecast,    # Para pronósticar series
quantmod,    # Para hacer gráficas atractivas
nortsTest,   # Para realizar pruebas de homocedasticidad
car          # Para generar gráficos de normalidad
)
# Prueba ARCH
arch.test(arima013)
# Prueba ARCH
arch.test(res)
# Limpieza de entorno
rm(list=ls())
gc()
dev.off()
pacman::p_load(tseries,     # Para usar series de tiempo
tidyverse,   # Paquete que contiene dplyr y GGplot2
forecast,    # Para pronósticar series
quantmod,    # Para hacer gráficas atractivas
nortsTest,   # Para realizar pruebas de homocedasticidad
car          # Para generar gráficos de normalidad
)
# Tomamos la serie de tiempo del PIB de Colombia
Data = read.csv(file.choose(), sep = ",")
View(Data)
colnames(Data) = c("Fecha", "Valor")
# Con Plot
plot(PIB, main = "PIB Colombia (Trimestral)")    # :/
# Con Plot
plot(PIB, main = "PIB Colombia (Trimestral)")    # :/
# Convertimos los datos en una serie de tiempo
PIB = ts(Data$Valor, start = c(2005, 2), end = c(2020,1), freq = 4)
# Con Plot
plot(PIB, main = "PIB Colombia (Trimestral)")    # :/
# Tengamos más estilo
chartSeries(PIB,
theme = chartTheme("white", up.col = "royalblue"),
show.grid = T,
TA = NULL,
name = "PIB Colombia (Trimestral)"
)                                    # B)
par(mfrow = c(1,2))
acf(PIB, main = "FAC del PIB")
pacf(PIB, main = "FACP del PIB")
par(mfrow = c(1,1))
pib = diff(log(PIB))
chartSeries(pib,
theme = chartTheme("white", up.col = "royalblue"),
show.grid = T,
TA = NULL,
name = "Tasa de crecimiento PIB Colombia (Trimestral)"
)
# FAC y FACP
par(mfrow = c(1,2))
acf(pib, main = "FAC del Δ% PIB")
pacf(pib, main = "FACP del  Δ% PIB")
par(mfrow = c(1,1))
par(mfrow = c(1,2))
acf(PIB, main = "FAC del PIB")
pacf(PIB, main = "FACP del PIB")
par(mfrow = c(1,1))
pib = diff(log(PIB))
chartSeries(pib,
theme = chartTheme("white", up.col = "royalblue"),
show.grid = T,
TA = NULL,
name = "Tasa de crecimiento PIB Colombia (Trimestral)"
)
# FAC y FACP
par(mfrow = c(1,2))
acf(pib, main = "FAC del Δ% PIB")
pacf(pib, main = "FACP del  Δ% PIB")
par(mfrow = c(1,1))
arima013 = arima(log(PIB), order = c(0,1,3),
include.mean = T, method = "ML")
arima013 = arima(log(PIB), order = c(0,1,3),
include.mean = T, method = "ML")
# Resultado del modelo
stargazer::stargazer(arima013, type = "text")
# Residuos del modelo
res = residuals(arima013)
# Residuos del modelo
res = residuals(arima013)
# FAC y FACP
par(mfrow = c(1,2))
acf(res, main = "FAC de los errores")
pacf(res, main = "FACP de los errores")
par(mfrow = c(1,1))
# Prueba Ljung - Box
Box.test(res, lag=4, type='Ljung-Box')
Box.test(res, lag=8, type='Ljung-Box')
# Prueba ARCH
arch.test(res)
# FAC y FACP
par(mfrow = c(1,2))
acf(res^2, main = "FAC del Δ% PIB")
pacf(res^2, main = "FACP del  Δ% PIB")
par(mfrow = c(1,1))
# Prueba ARCH
arch.test(res)
# QQplot
hist(res)
qqPlot(res)   # Observamos colas pesadas, sin embargo resulta muy subjetivo.
# QQplot
hist(res)
par(mfrow = c(1,1))
# QQplot
hist(res)
qqPlot(res)   # Observamos colas pesadas, sin embargo resulta muy subjetivo.
# Prueba Jarque Bera
jarque.bera.test(res)  # No se cumple la normalidad de los errores.
# Hacemos una predicción
pronostico = forecast::forecast(arima013, level = c(95), h =8, bootstrap = T)
# Valores Numéricos
pronostico
# En nivel
niveles = as.data.frame(pronostico)
exp(niveles)
# Pronóstico gráficamente.
autoplot(pronostico, predict.linetype = 'dashed', conf.int = T,
ylab = "Log PIB", xlab ="")+
ggtitle("Pronóstico del Log PIB de Colombia", subtitle = "(2020 Q2 - 2022 Q2)")
# Limpieza de entorno
rm(list = ls())
dev.off()
library(pacman)
pacman::p_load(
vars,         # Para usar modelos VAR
urca,         # Para realizar pruebas de raíz unitaria
tidyverse,    # Paquete que incluye ggplot2 y dplyr
ggfortify,    # Para graficar series de tiempo
gridExtra,    # Para concatenar gráficas en un solo plot
tidyr,        # Para ordenar y depurar datos
readxl        # Para leer archivos xlsx
)
set.seed(82901)
T = 300
y_t <- cbind(rep(0, T),rep(0, T))
u_t = cbind(rnorm(T), rnorm(T))
A_1 = cbind(c(0.3, 0.5), c(0.2, 0.6))
sim = function(y_t, A_1, u_t, T){
for (i in 2:T) {
y_t[i,] = A_1 %*% y_t[i-1,] + u_t[i,]
}
return(y_t)
}
y_t = sim(y_t, A_1, u_t, T) # La función sim lo que busca es llenar la matriz
y_t=ts(y_t, start=c(1900,1), frequency=4)
y1 = autoplot(y_t[,1], size=1,ts.colour="lightblue",
xlab="",ylab="", main="Variable y_1")
y2 = autoplot(y_t[,2], size=1,ts.colour="darkolivegreen4",
xlab="",ylab="", main="Variable y_2")
x11();grid.arrange(y1,y2,ncol=2)
y1 = autoplot(y_t[,1], size=1,ts.colour="lightblue",
xlab="",ylab="", main="Variable y_1")
y2 = autoplot(y_t[,2], size=1,ts.colour="darkolivegreen4",
xlab="",ylab="", main="Variable y_2")
x11();grid.arrange(y1,y2,ncol=2)
adf1= ur.df(y_t[,1], lags=3,selectlags = "AIC",type="none")
summary(adf1) # Rechazo H0, la serie es I(0)
adf2= ur.df(y_t[,2], lags=3,selectlags = "AIC",type="none")
summary(adf2) # Rechazo H0, la serie es I(0)
adf1= ur.df(y_t[,1], lags=3,selectlags = "AIC",type="trend")
summary(adf1) # Rechazo H0, la serie es I(0)
adf2= ur.df(y_t[,2], lags=3,selectlags = "AIC",type="trend")
summary(adf2) # Rechazo H0, la serie es I(0)
adf2= ur.df(y_t[,2], lags=3,selectlags = "AIC",type="none")
summary(adf2) # Rechazo H0, la serie es I(0)
# Selección de rezagos para un VAR con tendencia e intercepto.
VARselect(y_t, lag.max=6,type = "both", season = NULL)
# Selección de rezagos para un VAR con sólo intercepto.
VARselect(y_t, lag.max=6,type = "const", season = NULL)
# Selección de rezagos para un VAR sin términos determinísticos.
VARselect(y_t, lag.max=6,type = "none", season = NULL)
# VAR con tendencia e intercepto
V.tr = VAR(y_t, p=1, type="both", season=NULL)
summary(V.tr) # La tendencia no es significativa, analizamos const
# VAR con intercepto.
V.dr= VAR(y_t, p=1, type="const", season=NULL)
summary(V.dr) # El intercepto es significativo en una ecuación, veamos none
# VAR con tendencia e intercepto
V.tr = VAR(y_t, p=1, type="both", season=NULL)
summary(V.tr) # La tendencia no es significativa, analizamos const
# VAR con intercepto.
V.dr= VAR(y_t, p=1, type="const", season=NULL)
summary(V.dr) # El intercepto es significativo en una ecuación, veamos none
# VAR sin términos determinísticos.
V.no = VAR(y_t, p=1, type="none", season=NULL)
summary(V.no)
A_0 = cbind(2,2)
sim = function(y_t, A_1, u_t, T){
for (i in 2:T) {
y_t[i,] = A_0 + A_1 %*% y_t[i-1,] + u_t[i,]
}
return(y_t)
}
y_t = sim(y_t, A_1, u_t, T) # La función sim lo que busca es llenar la matriz
A_0
A_0 = rbind(2,2)
sim = function(y_t, A_1, u_t, T){
for (i in 2:T) {
y_t[i,] = A_0 + A_1 %*% y_t[i-1,] + u_t[i,]
}
return(y_t)
}
y_t = sim(y_t, A_1, u_t, T) # La función sim lo que busca es llenar la matriz
y_t=ts(y_t, start=c(1900,1), frequency=4)
y1 = autoplot(y_t[,1], size=1,ts.colour="lightblue",
xlab="",ylab="", main="Variable y_1")
y2 = autoplot(y_t[,2], size=1,ts.colour="darkolivegreen4",
xlab="",ylab="", main="Variable y_2")
x11();grid.arrange(y1,y2,ncol=2)
A_0 = rbind(1,1)
sim = function(y_t, A_1, u_t, T){
for (i in 2:T) {
y_t[i,] = A_0 + A_1 %*% y_t[i-1,] + u_t[i,]
}
return(y_t)
}
y_t = sim(y_t, A_1, u_t, T) # La función sim lo que busca es llenar la matriz
y_t=ts(y_t, start=c(1900,1), frequency=4)
y1 = autoplot(y_t[,1], size=1,ts.colour="lightblue",
xlab="",ylab="", main="Variable y_1")
y2 = autoplot(y_t[,2], size=1,ts.colour="darkolivegreen4",
xlab="",ylab="", main="Variable y_2")
x11();grid.arrange(y1,y2,ncol=2)
A_1 = cbind(c(0.3, 0.4), c(0.2, 0.6))
A_0 = rbind(1,1)
sim = function(y_t, A_1, u_t, T){
for (i in 2:T) {
y_t[i,] = A_0 + A_1 %*% y_t[i-1,] + u_t[i,]
}
return(y_t)
}
y_t = sim(y_t, A_1, u_t, T) # La función sim lo que busca es llenar la matriz
y_t=ts(y_t, start=c(1900,1), frequency=4)
y1 = autoplot(y_t[,1], size=1,ts.colour="lightblue",
xlab="",ylab="", main="Variable y_1")
y2 = autoplot(y_t[,2], size=1,ts.colour="darkolivegreen4",
xlab="",ylab="", main="Variable y_2")
x11();grid.arrange(y1,y2,ncol=2)
adf1= ur.df(y_t[,1], lags=3,selectlags = "AIC",type="none")
summary(adf1) # Rechazo H0, la serie es I(0)
adf2= ur.df(y_t[,2], lags=3,selectlags = "AIC",type="none")
summary(adf2) # Rechazo H0, la serie es I(0)
adf1= ur.df(y_t[,1], lags=3,selectlags = "AIC",type="trend")
summary(adf1) # Rechazo H0, la serie es I(0)
adf1= ur.df(y_t[,1], lags=12,selectlags = "AIC",type="trend")
summary(adf1) # Rechazo H0, la serie es I(0)
adf1= ur.df(y_t[,1], lags=1,selectlags = "AIC",type="trend")
summary(adf1) # Rechazo H0, la serie es I(0)
adf1= ur.df(y_t[,1], lags=50,selectlags = "AIC",type="trend")
summary(adf1) # Rechazo H0, la serie es I(0)
adf1= ur.df(y_t[,1], lags=3,selectlags = "AIC",type="trend")
summary(adf1) # Rechazo H0, la serie es I(0)
adf2= ur.df(y_t[,2], lags=3,selectlags = "AIC",type="none")
summary(adf2) # Rechazo H0, la serie es I(0)
A_1 = cbind(c(0.3, 0.5), c(0.2, 0.6))
A_0 = rbind(0.5,0.5)
sim = function(y_t, A_1, u_t, T){
for (i in 2:T) {
y_t[i,] = A_0 + A_1 %*% y_t[i-1,] + u_t[i,]
}
return(y_t)
}
y_t = sim(y_t, A_1, u_t, T) # La función sim lo que busca es llenar la matriz
y_t=ts(y_t, start=c(1900,1), frequency=4)
y1 = autoplot(y_t[,1], size=1,ts.colour="lightblue",
xlab="",ylab="", main="Variable y_1")
y2 = autoplot(y_t[,2], size=1,ts.colour="darkolivegreen4",
xlab="",ylab="", main="Variable y_2")
x11();grid.arrange(y1,y2,ncol=2)
adf1= ur.df(y_t[,1], lags=3,selectlags = "AIC",type="trend")
summary(adf1) # Rechazo H0, la serie es I(0)
adf1= ur.df(y_t[,1], lags=3,selectlags = "AIC",type="none")
summary(adf1) # Rechazo H0, la serie es I(0)
adf2= ur.df(y_t[,2], lags=3,selectlags = "AIC",type="none")
summary(adf2) # Rechazo H0, la serie es I(0)
# Selección de rezagos para un VAR con tendencia e intercepto.
VARselect(y_t, lag.max=6,type = "both", season = NULL)
# Selección de rezagos para un VAR con sólo intercepto.
VARselect(y_t, lag.max=6,type = "const", season = NULL)
# Selección de rezagos para un VAR sin términos determinísticos.
VARselect(y_t, lag.max=6,type = "none", season = NULL)
# VAR con tendencia e intercepto
V.tr = VAR(y_t, p=1, type="both", season=NULL)
summary(V.tr) # La tendencia no es significativa, analizamos const
# VAR con intercepto.
V.dr= VAR(y_t, p=1, type="const", season=NULL)
summary(V.dr) # El intercepto es significativo en una ecuación, veamos none
# VAR sin términos determinísticos.
V.no = VAR(y_t, p=1, type="none", season=NULL)
summary(V.no)
# PT.asymptotic es para muestra grande y "PT.adjusted" para muestra pequeña.
P.75=serial.test(V.no, lags.pt = 75, type = "PT.asymptotic");P.75 # No rechazo
P.30=serial.test(V.no, lags.pt = 30, type = "PT.asymptotic");P.30 # No rechazo
P.20=serial.test(V.no, lags.pt = 20, type = "PT.asymptotic");P.20 # No rechazo
P.10=serial.test(V.no, lags.pt = 10, type = "PT.asymptotic");P.10 # No rechazo
plot(P.20, names = "Series.1") # Los residuales de la primera serie se comportan bien
plot(P.20, names = "Series.2") # Los residuales de la segunda serie se comportan bien
# Test tipo ARCH multivariado
arch.test(V.no, lags.multi = 24, multivariate.only = TRUE) # No rechazo
arch.test(V.no, lags.multi = 12, multivariate.only = TRUE) # No rechazo
# Jarque-Bera para series multivariadas.
normality.test(V.no) #No rechazo, se cumple el supuesto.
tseries::jarque.bera.test(V.no)
tseries::jarque.bera.test(residuals(V.no)
tseries::jarque.bera.test(residuals(V.no))
jarque.bera.test(residuals(V.no))
jarqueBera(residuals(V.no))
hist(V.no)
hist(residuals(V.no))
x11()
predict(V.no, n.ahead = 12,ci=0.95)
autoplot(predict(V.no, n.ahead = 12,ci=0.95))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","blue"))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("lightblue","blue3"))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"),
cis = T)
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"),
cis = 1)
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"),
cis = 0.99)
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"),
cis = 0.999999)
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"),
cis = 0.5)
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"),
cis = 0.95)
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"),
names = c("Pronóstico 1", "Pronóstico 2"))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"),
names = c(y))
# Versión Fanchart
fanchart(predict(V.no, n.ahead = 12), colors = c("blue","lightblue"))
pasos_adelante = 0:18
impulso_respuesta = function(var, impulso, respuesta, pasos_adelante, ortog,
int_conf, titulo){
"Función diseñada por German Camilo Rodriguez"
"Calcula las funciones impulso respuesta ortogonalizadas y no ortogonalizadas
y devuelve una grafíca IRF o OIRF dependiendo la especificación"
# Cáclulo de la función impulso respuesta
total_pasos_futuros = length(pasos_adelante) - 1
IRF = irf(var, impulse=impulso, response=respuesta, n.ahead = total_pasos_futuros,
ortho=ortog, ci = int_conf)
IRF_data_frame = data.frame(IRF$irf,IRF$Lower,IRF$Upper, pasos_adelante)
# Gráfica de la función impulso respuesta
graph = IRF_data_frame %>%
ggplot(aes(x=IRF_data_frame[,4], y=IRF_data_frame[,1], ymin=IRF_data_frame[,2],
ymax=IRF_data_frame[,3] )) +
geom_hline(yintercept = 0, color="red") +
geom_ribbon(fill="grey", alpha=0.2) +
geom_line() +
theme_light() +
ggtitle(titulo)+
ylab("")+
xlab("pasos adelante") +
theme(plot.title = element_text(size = 11, hjust=0.5),
axis.title.y = element_text(size=11))
return(graph)
}
y1.y1 = impulso_respuesta(V.no, "Series.1", "Series.1", pasos_adelante, ortog = F,
int_conf = 0.95, titulo = "Impulso de y1 - respuesta de y1")
y1.y2 = impulso_respuesta(V.no, "Series.1", "Series.2", pasos_adelante, ortog = F,
int_conf = 0.95, titulo = "Impulso de y1 - respuesta de y2")
y2.y1 = impulso_respuesta(V.no, "Series.2", "Series.1", pasos_adelante, ortog = F,
int_conf = 0.95, titulo = "Impulso de y2 - respuesta de y1")
y2.y2 = impulso_respuesta(V.no, "Series.2", "Series.2", pasos_adelante, ortog = F,
int_conf = 0.95, titulo = "Impulso de y2 - respuesta de y2")
grid.arrange(y1.y1,y1.y2,y2.y1,y2.y2,ncol=2)
y1.y1. = impulso_respuesta(V.no, "Series.1", "Series.1", pasos_adelante, ortog = T,
int_conf = 0.95, titulo = "Impulso ortogonal de y1 - respuesta de y1")
y1.y1. = impulso_respuesta(V.no, "Series.1", "Series.1", pasos_adelante, ortog = T,
int_conf = 0.95, titulo = "Impulso ortogonal de y1 - respuesta de y1")
y1.y2. = impulso_respuesta(V.no, "Series.1", "Series.2", pasos_adelante, ortog = T,
int_conf = 0.95, titulo = "Impulso ortogonal de y1 - respuesta de y2")
y2.y1. = impulso_respuesta(V.no, "Series.2", "Series.1", pasos_adelante, ortog = T,
int_conf = 0.95, titulo = "Impulso ortogonal de y2 - respuesta de y1")
y2.y2. = impulso_respuesta(V.no, "Series.2", "Series.2", pasos_adelante, ortog = T,
int_conf = 0.95, titulo = "Impulso ortogonal de y2 - respuesta de y2")
grid.arrange(y1.y1.,y1.y2.,y2.y1.,y2.y2.,ncol=2)
fevd(V.no, n.ahead = 18)
plot(fevd(V.no, n.ahead = 18),col=c("orange3", "firebrick4"))
Phi(V.no,nstep=10) # Esta función nos calcula la matriz de coeficientes
Psi(V.no,nstep=10)
# Definimos la base de datos y las variables en nivel
Base = read_excel(file.choose())
IPI = ts(Base$IPI, start=c(1960,1), frequency=4)
CPI= ts(Base$CPI, start=c(1960,1),  frequency=4)
UNEM = ts(Base$Unem, start=c(1960,1), frequency=4)
dl.IPI = diff(log(IPI))
d.CPI = diff(log(CPI))
autoplot(dl.IPI, size=1, colour="lightblue", xlab="Año", ylab="Porcentaje",
main="Tasa de crecimeinto IPI")+labs(subtitle = "USA (1960-2012)")
autoplot(CPI, size=1, colour="sienna1", xlab="Año",  ylab="Porcentaje",
main="Variación de CPI")+ labs(subtitle = "USA (1960-2012)")
autoplot(UNEM, size=1, colour="mediumpurple2", xlab="Año", ylab="Porcentaje",
main="Tasa de desempleo")+ labs(subtitle = "USA (1960-2012)")
#Tasa de crecimiento IPI
adf3= ur.df(dl.IPI, lags=6, selectlags="AIC", type="drift")
summary(adf3) # La serie es estacionaria y con intercepto
#Tasa de crecimiento IPI
adf3= ur.df(dl.IPI, lags=6, selectlags="AIC", type="trend")
summary(adf3) # La serie es estacionaria y con intercepto
#Tasa de crecimiento IPI
adf3= ur.df(dl.IPI, lags=6, selectlags="AIC", type="none")
summary(adf3) # La serie es estacionaria y con intercepto
#Variación del CPI
adf4= ur.df(CPI, lags=6, selectlags="AIC", type="trend")
summary(adf4) # La serie es estacionaria y con intercepto.
#Tasa de desempleo
adf5= ur.df(UNEM, lags=6, selectlags="AIC", type="drift")
summary(adf5) # La serie es estacionaria y con intercepto.
#Tasa de desempleo
adf5= ur.df(UNEM, lags=6, selectlags="AIC", type="trend")
summary(adf5) # La serie es estacionaria y con intercepto.
#Tasa de desempleo
adf5= ur.df(UNEM, lags=6, selectlags="AIC", type="drift")
summary(adf5) # La serie es estacionaria y con intercepto.
# Definimos una matriz con las variables, con el siguiente ordenamiento
Unem = UNEM[1:211]
Y = cbind(dl.IPI,Unem,d.CPI)
#Selección de rezagos para un VAR con sólo intercepto.
VARselect(Y, lag.max=6,type = "const", season = NULL) # Elegimos 3 rezagos
#Selección de rezagos para un VAR sin términos determinísticos.
VARselect(Y, lag.max=6,type = "none", season = NULL) # Elegimos 5 rezagos
# VAR con sólo intercepto.
V.dr.1= VAR(Y, p=3, type="const", season=NULL)
summary(V.dr.1) # El intercepto es significativo en una ecuación.
# Raíces del proceso
roots(V.dr.1) # El proceso es estable.
#Coeficientes:
Acoef(V.dr.1) #Presenta los resultados de la matriz A_1, A_2 y A_3
#Matriz de varianzas y covarianzas de los residuales
Sigma.e = summary(V.dr.1)$covres
Sigma.e
# VAR con sólo intercepto.
V.dr.1= VAR(Y, p=3, type="both", season=NULL)
summary(V.dr.1) # El intercepto es significativo en una ecuación.
